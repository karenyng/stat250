<h1 id="lecture-8">Lecture 8</h1>
<p>&quot;R underscore alloc&quot; R will actually clean memory if you hit control C! If we use call C from R and use malloc &lt;- if you terminate the code, there would be memory leak.....</p>
<h1 id="if-we-have-to-stick-with-r-....">If we have to stick with R ....</h1>
<p>read.csv(con, nrow = totallines) &lt;- preallocate memory will avoid having to grow memory and speed up the code</p>
<p>can use read.csv for only extracting one column colClasses = (NULL, NULL, NULL, ..., the column that we want, ..., NULL)</p>
<p>*.csv &lt;- globing NOT regular expression!</p>
<h1 id="shell-way-of-parallelization">Shell way of parallelization</h1>
<p>grep -v 1987.csv 1988.csv ... 1992.csv | ... &gt; early &amp; grep -v 1993.csv 1988.csv ... 1998.csv | ... &gt; mid &amp;</p>
<p>where early / mid / late are frequency tables and we can just combine them</p>
<p>But hard to find out if the processes finished or not have to look up the PID and possibly check through the top command.</p>
<h1 id="java">Java</h1>
<p>pthread</p>
<h1 id="duncans-answer-to-hw2">Duncan's answer to hw2</h1>
<p>fs = [list of file names] ff = function(fs) for (f in fs) setfreqtable(f) cl = makeCluster(10, &quot;FORK&quot;) tables = clusterApply(cl, ff, f)</p>
<p>if we have a 100 files and we have 10 cores, to divide the files in groups for 10 do: ClusterSplit(cl, ff) #give a list of character to equally distribute them<br />g = clusterSplit(cl, ff) clusterApply(cl, g, f)</p>
<p>clusterApplyLB &lt;- load balancing!</p>
